// Code generated by protoc-gen-go. DO NOT EDIT.
// source: dcm.proto

package dcm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A block of data, to simply increase gRPC message size and test.
type Payload struct {
	// Primary contents of payload.
	Body                 []byte   `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcm_dacae163251c6f7d, []int{0}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Payload.Unmarshal(m, b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
}
func (dst *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(dst, src)
}
func (m *Payload) XXX_Size() int {
	return xxx_messageInfo_Payload.Size(m)
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

// diagnostic data request message.
type DiagResponse struct {
	Code                 int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiagResponse) Reset()         { *m = DiagResponse{} }
func (m *DiagResponse) String() string { return proto.CompactTextString(m) }
func (*DiagResponse) ProtoMessage()    {}
func (*DiagResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcm_dacae163251c6f7d, []int{1}
}
func (m *DiagResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DiagResponse.Unmarshal(m, b)
}
func (m *DiagResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DiagResponse.Marshal(b, m, deterministic)
}
func (dst *DiagResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiagResponse.Merge(dst, src)
}
func (m *DiagResponse) XXX_Size() int {
	return xxx_messageInfo_DiagResponse.Size(m)
}
func (m *DiagResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiagResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiagResponse proto.InternalMessageInfo

func (m *DiagResponse) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DiagResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// diagnostic data response message.
type DiagRecorderData struct {
	CanId                int32    `protobuf:"varint,1,opt,name=canId,proto3" json:"canId,omitempty"`
	Payload              *Payload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiagRecorderData) Reset()         { *m = DiagRecorderData{} }
func (m *DiagRecorderData) String() string { return proto.CompactTextString(m) }
func (*DiagRecorderData) ProtoMessage()    {}
func (*DiagRecorderData) Descriptor() ([]byte, []int) {
	return fileDescriptor_dcm_dacae163251c6f7d, []int{2}
}
func (m *DiagRecorderData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DiagRecorderData.Unmarshal(m, b)
}
func (m *DiagRecorderData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DiagRecorderData.Marshal(b, m, deterministic)
}
func (dst *DiagRecorderData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiagRecorderData.Merge(dst, src)
}
func (m *DiagRecorderData) XXX_Size() int {
	return xxx_messageInfo_DiagRecorderData.Size(m)
}
func (m *DiagRecorderData) XXX_DiscardUnknown() {
	xxx_messageInfo_DiagRecorderData.DiscardUnknown(m)
}

var xxx_messageInfo_DiagRecorderData proto.InternalMessageInfo

func (m *DiagRecorderData) GetCanId() int32 {
	if m != nil {
		return m.CanId
	}
	return 0
}

func (m *DiagRecorderData) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func init() {
	proto.RegisterType((*Payload)(nil), "dcm.Payload")
	proto.RegisterType((*DiagResponse)(nil), "dcm.DiagResponse")
	proto.RegisterType((*DiagRecorderData)(nil), "dcm.DiagRecorderData")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DCMServiceClient is the client API for DCMService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DCMServiceClient interface {
	// DCM to Server client side streaming of diagnostic data
	DiagnosticData(ctx context.Context, in *DiagRecorderData, opts ...grpc.CallOption) (*DiagResponse, error)
	DiagnosticDataStream(ctx context.Context, opts ...grpc.CallOption) (DCMService_DiagnosticDataStreamClient, error)
}

type dCMServiceClient struct {
	cc *grpc.ClientConn
}

func NewDCMServiceClient(cc *grpc.ClientConn) DCMServiceClient {
	return &dCMServiceClient{cc}
}

func (c *dCMServiceClient) DiagnosticData(ctx context.Context, in *DiagRecorderData, opts ...grpc.CallOption) (*DiagResponse, error) {
	out := new(DiagResponse)
	err := c.cc.Invoke(ctx, "/dcm.DCMService/DiagnosticData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dCMServiceClient) DiagnosticDataStream(ctx context.Context, opts ...grpc.CallOption) (DCMService_DiagnosticDataStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DCMService_serviceDesc.Streams[0], "/dcm.DCMService/DiagnosticDataStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &dCMServiceDiagnosticDataStreamClient{stream}
	return x, nil
}

type DCMService_DiagnosticDataStreamClient interface {
	Send(*DiagRecorderData) error
	CloseAndRecv() (*DiagResponse, error)
	grpc.ClientStream
}

type dCMServiceDiagnosticDataStreamClient struct {
	grpc.ClientStream
}

func (x *dCMServiceDiagnosticDataStreamClient) Send(m *DiagRecorderData) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dCMServiceDiagnosticDataStreamClient) CloseAndRecv() (*DiagResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(DiagResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DCMServiceServer is the server API for DCMService service.
type DCMServiceServer interface {
	// DCM to Server client side streaming of diagnostic data
	DiagnosticData(context.Context, *DiagRecorderData) (*DiagResponse, error)
	DiagnosticDataStream(DCMService_DiagnosticDataStreamServer) error
}

func RegisterDCMServiceServer(s *grpc.Server, srv DCMServiceServer) {
	s.RegisterService(&_DCMService_serviceDesc, srv)
}

func _DCMService_DiagnosticData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiagRecorderData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DCMServiceServer).DiagnosticData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dcm.DCMService/DiagnosticData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DCMServiceServer).DiagnosticData(ctx, req.(*DiagRecorderData))
	}
	return interceptor(ctx, in, info, handler)
}

func _DCMService_DiagnosticDataStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DCMServiceServer).DiagnosticDataStream(&dCMServiceDiagnosticDataStreamServer{stream})
}

type DCMService_DiagnosticDataStreamServer interface {
	SendAndClose(*DiagResponse) error
	Recv() (*DiagRecorderData, error)
	grpc.ServerStream
}

type dCMServiceDiagnosticDataStreamServer struct {
	grpc.ServerStream
}

func (x *dCMServiceDiagnosticDataStreamServer) SendAndClose(m *DiagResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dCMServiceDiagnosticDataStreamServer) Recv() (*DiagRecorderData, error) {
	m := new(DiagRecorderData)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _DCMService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dcm.DCMService",
	HandlerType: (*DCMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DiagnosticData",
			Handler:    _DCMService_DiagnosticData_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DiagnosticDataStream",
			Handler:       _DCMService_DiagnosticDataStream_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "dcm.proto",
}

func init() { proto.RegisterFile("dcm.proto", fileDescriptor_dcm_dacae163251c6f7d) }

var fileDescriptor_dcm_dacae163251c6f7d = []byte{
	// 229 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x90, 0xc1, 0x4a, 0x03, 0x31,
	0x10, 0x86, 0x8d, 0x5a, 0x97, 0x8e, 0x8b, 0xe8, 0x50, 0x61, 0x11, 0x84, 0xb2, 0x07, 0xd9, 0x53,
	0x0f, 0xf5, 0xda, 0x9b, 0x7b, 0xf1, 0x20, 0x94, 0xf4, 0x09, 0xa6, 0xc9, 0x50, 0x16, 0xcc, 0xce,
	0x92, 0x04, 0xa1, 0x6f, 0xe1, 0x23, 0xcb, 0x26, 0x5d, 0x50, 0x6f, 0xbd, 0xcd, 0x24, 0xf9, 0xbe,
	0xf9, 0x33, 0x30, 0xb7, 0xc6, 0xad, 0x06, 0x2f, 0x51, 0xf0, 0xca, 0x1a, 0x57, 0x3f, 0x43, 0xb1,
	0xa5, 0xe3, 0xa7, 0x90, 0x45, 0x84, 0xeb, 0xbd, 0xd8, 0x63, 0x75, 0xb9, 0x54, 0x4d, 0xa9, 0x53,
	0x5d, 0x6f, 0xa0, 0x6c, 0x3b, 0x3a, 0x68, 0x0e, 0x83, 0xf4, 0x81, 0xc7, 0x37, 0x46, 0x2c, 0x57,
	0x6a, 0xa9, 0x9a, 0x99, 0x4e, 0x35, 0x56, 0x50, 0x38, 0x0e, 0x81, 0x0e, 0x9c, 0xd0, 0xb9, 0x9e,
	0xda, 0x7a, 0x0b, 0xf7, 0x99, 0x36, 0xe2, 0x2d, 0xfb, 0x96, 0x22, 0xe1, 0x02, 0x66, 0x86, 0xfa,
	0x77, 0x7b, 0x52, 0xe4, 0x06, 0x5f, 0xa0, 0x18, 0x72, 0x8c, 0xe4, 0xb8, 0x5d, 0x97, 0xab, 0x31,
	0xe8, 0x29, 0x9a, 0x9e, 0x2e, 0xd7, 0xdf, 0x0a, 0xa0, 0x7d, 0xfb, 0xd8, 0xb1, 0xff, 0xea, 0x0c,
	0xe3, 0x06, 0xee, 0xc6, 0x01, 0xbd, 0x84, 0xd8, 0x99, 0xa4, 0x7f, 0x4c, 0xdc, 0xff, 0xa9, 0x4f,
	0x0f, 0xbf, 0x8e, 0xf3, 0x57, 0xea, 0x0b, 0x6c, 0x61, 0xf1, 0x97, 0xde, 0x45, 0xcf, 0xe4, 0xce,
	0x71, 0x34, 0x6a, 0x7f, 0x93, 0xb6, 0xf9, 0xfa, 0x13, 0x00, 0x00, 0xff, 0xff, 0x6a, 0x28, 0xbb,
	0x42, 0x5a, 0x01, 0x00, 0x00,
}
